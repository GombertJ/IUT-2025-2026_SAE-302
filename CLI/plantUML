@startuml
!theme mars
skinparam classAttributeIconSize 0

package "Core" {
  class ServiceRegistry <<singleton>> {
    - Map<Class, Object> services
    {static} register(Class<T>, T) : void
    {static} get(Class<T>) : T
  }
}

package "CLI (Picocli)" {
class Main <<class>> {
- ConfigManager configManager
- ShellService shellService
{static} main(args : String[]) : void
}

class Setup <<class>> {
{static} Setup() : void
+ call() : int
+ installDependencies() : void
}
}

package "Interactive Shell (JLine)" {
class ShellService <<class>> {
- LineReader reader
- ModuleManager moduleManager
- DatabaseService database
{static} ShellService() : void
+ start() : void
+ stop() : void
+ handleUserInput(line : String) : void
}
}

package "Modules" {

interface Module {

* String getName()
* String getDescription()
* Map<String, Option> getOptions()
* void setOption(String key, String value) throws IllegalArgumentException
* Optional<String> getOption(String key)
* void run() throws ModuleExecutionException
* String info()
  }

abstract class AbstractModule implements Module {

* final Map<String, Option> options
* final String name
* final String description

{static} AbstractModule(name : String, description : String)
- void registerOption(String name, String defaultValue, String description, boolean required)
- Map<String, Option> getOptions()
- void setOption(String key, String value)
- Optional<String> getOption(String key)
- void showOptions(out : java.io.PrintStream)
- String info()
- String getName()
- String getDescription()
  }

class Option {

* final String name
* final String defaultValue
* String value
* final String description
* final boolean required

{static} Option(name : String, defaultValue : String, description : String, required : boolean)
- String getName()
- Optional<String> getValue()
- void setValue(String value)
- String getDescription()
- boolean isRequired()
- boolean isSet()
  }

class NmapModule extends AbstractModule {

{static} NmapModule()
* void run() throws ModuleExecutionException
* String getName()
* String getDescription()
  }

class ExampleExploit extends AbstractModule {

{static} ExampleExploit()
* void run() throws ModuleExecutionException
* String getName()
* String getDescription()
  }

class ModuleManager {

* final java.util.concurrent.ConcurrentMap<String, Module> modules

{static} ModuleManager()
- void register(Module m) throws IllegalArgumentException
- Optional<Module> get(String name)
- Collection<Module> list()
- List<Module> search(String prefix)
  }

class ModuleExecutionException <<exception>> {

{static} ModuleExecutionException(message : String)
  }

}

package "Database" {
class Vulnerability <<entity>> {
- String id
- String name
- String target
- String state
- String infos
}

class DatabaseService <<service>> {
- DatabaseRepository repo
{static} DatabaseService(repo : DatabaseRepository)
+ saveVulnerability(v : Vulnerability) : void
+ saveScan(scanId : String, payload : Map) : void
+ query(host : String) : List<Vulnerability>
}

interface DatabaseRepository {
+ insertVulnerability(v : Vulnerability) : void
+ insertScan(scanId : String, payload : Map) : void
+ find(host : String) : List<Vulnerability>
}
class SQLiteRepository <<sql>> {
    - java.sql.Connection conn
    {static} SQLiteRepository(dbPath : String)
    + insertVulnerability(v : Vulnerability) : void
    + insertScan(scanId : String, payload : Map) : void
    + find(host : String) : List<Vulnerability>
    + connect() : void
}
}

package "Configuration" {
  class ConfigManager <<service>> {
    - Path path
    - Config config
    {static} ConfigManager(path : Path)
    + Config load() : Config
    + void save(c : Config)
    + Config getConfig()
    + void setPath(Path : String)
  }
}
' ======= Relationships =======
Main --> ShellService
Main --> ConfigManager

ShellService --> ModuleManager
ShellService --> DatabaseService

ModuleManager "1" o-- "*" Module : manages
AbstractModule "1" *-- "*" Option : contains

DatabaseService ..> DatabaseRepository

DatabaseRepository <|.. SQLiteRepository
@enduml
